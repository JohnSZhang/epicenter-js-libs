/**
 * ##World API Adapter
 *
 * The World API Adapter allows you to create, access, and manipulate multiplayer worlds its users and runs
 *
 * All API calls take in an "options" object as the last parameter. The options can be used to extend/override the World API Service defaults.
 *
 *
 */

'use strict';

var ConfigService = require('./configuration-service');
var StorageFactory = require('../store/store-factory');
// var qutil = require('../util/query-util');
var TransportFactory = require('../transport/http-transport-factory');
var _pick = require('../util/object-util')._pick;

var apiBase = 'multiplayer/';
var assignmentEndpoint = apiBase + 'assign';
var apiEndpoint = apiBase + 'game';
var projectEndpoint = apiBase + 'project';

module.exports = function (config) {
    var store = new StorageFactory({ synchronous: true });

    var defaults = {

       token: store.get('epicenter.project.token') || '',

       project: undefined,

       account: undefined,

       group: undefined,

//        apiKey: '',

//        domain: 'forio.com',

        //Options to pass on to the underlying transport layer
        transport: {},

        success: $.noop,

        error: $.noop
    };

    var serviceOptions = $.extend({}, defaults, config);
    var urlConfig = new ConfigService(serviceOptions).get('server');

    var transportOptions = $.extend(true, {}, serviceOptions.transport, {
        url: urlConfig.getAPIPath(apiEndpoint)
    });

    if (serviceOptions.token) {
        transportOptions.headers = {
            'Authorization': 'Bearer ' + serviceOptions.token
        };
    }

    var http = new TransportFactory(transportOptions);

    var setIdFilterOrThrowError = function (options) {
        if (options.filter) {
            serviceOptions.filter = options.filter;
        }
        if (!serviceOptions.filter) {
            throw new Error('No filter specified to apply operations against');
        }
    };

    var publicAPI = {

        /**
        * Create a new World
        *
        * ** Example **
        *   var gm = new F.service.World({ account: 'account', project: 'project' });
        *   gm.create({ model: 'model.py', group: 'group-name' });
        *
        * ** Parameters **
        * @param {object} `params` Parameters to create the world
        * @param {string} `params.model` The model file to use to create runs in this world
        * @param {string} `params.group` the group _name_ to create this world under
        * @param {string} `params.roles` (Optional) The list of roles for this world
        * @param {string} `params.opionalRoles` (Optional) The list of optional roles for this world
        * @param {string} `params.minUsers` (Optional) The minimum number of users for the world
        * @param {string} `params.name` (Optional) A name for the world
        * @param {object} `options` Options object to override global options
        *
        */
        create: function (params, options) {
            var createOptions = $.extend(true, {}, serviceOptions, options, { url: urlConfig.getAPIPath(apiEndpoint) });
            var worldApiParams = ['model', 'scope', 'files', 'roles', 'optionalRoles', 'minUsers', 'group', 'name'];
            if (typeof params === 'string') {
                // this is just the model name
                params = { model: params };
            } else {
                // whitelist the fields that we actually can send to the api
                params = _pick(params, worldApiParams);
            }

            // account and project go in the body, not in the url
            $.extend(params, _pick(serviceOptions, ['account', 'project', 'group']));

            var oldSuccess = createOptions.success;
            createOptions.success = function (response) {
                serviceOptions.filter = response.id; //all future chained calls to operate on this id
                return oldSuccess.apply(this, arguments);
            };

            return http.post(params, createOptions);
        },

        /**
        * Update a World object, for example to add the roles to the world
        *
        */
        update: function (params, options) {
            var whitelist = ['roles', 'optionalRoles', 'minUsers'];
            options = options || {};
            setIdFilterOrThrowError(options);

            var updateOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter }
            );

            params = _pick(params || {}, whitelist);

            return http.patch(params, updateOptions);
        },

        /**
        * Delete an existing world
        *
        */
        delete: function (options) {
            options = options || {};
            setIdFilterOrThrowError(options);

            var deleteOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter }
            );

            return http.delete(null, deleteOptions);
        },

        /**
        * Set the filter for the current instance of the world adapter
        *
        * **Example**
        * var ws = new F.service.World({...}).load('123').addUser({ userId: '123' });
        *
        *
        */
        load: function (worldId) {
            if (!worldId || typeof worldId !== 'string') {
                throw new Error('load needs a worldId string to load (' + worldId + ')');
            }

            serviceOptions.filter = worldId;

            return this;
        },

        /**
        * List all worlds for a given account/project/group
        *
        *
        */
        list: function (options) {
            options = options || {};

            var getOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) }
            );

            var filters = _pick(getOptions, ['account', 'project', 'group']);

            return http.get(filters, getOptions);
        },

        /**
        * Get all worlds that a user belongs to for the given account/project/group
        *
        * ** Parameters **
        * @param {string} `userId` - userId of the user you need the world for
        * @param {object} `options` (optional) - overrides to the global options object
        */
        getWorldsForUser: function (userId, options) {
            options = options || {};

            var getOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) }
            );

            var filters = $.extend(
                _pick(getOptions, ['account', 'project', 'group']),
                { userId: userId }
            );

            return http.get(filters, getOptions);
        },

        /**
        * Add a user or list of users to a given world
        *
        * Supported format for users
        * wm.addUsers('123-123-123-123');
        * wm.addUsers({ userId: '123-123-123-123', role: 'abc' });
        * wm.addUsers(['123-123-123-123', '312-321-321-321']);
        * wm.addUsers([{ userId: '123-123-123-123', role: 'abc' }, { userId: '312-321-321-321' }]);
        *
        * note that options can be passed as the second parameter, so these calls are both valid
        *   wm.addUser('123-123-123', 'game1')
        *   wm.addUser('123-123-123', { filter: game1 })
        *
        * @param users {string|object|array} the users to add to the world
        * @param worldId {string} (optional) the worldId to add the users to.
        *       If not specified it will take the filter paramter of the options or the filter populated from previous calls
        * @param options {object} (optional)
        */
        addUsers: function (users, worldId, options) {

            if (!users) {
                throw new Error('Please provide a list of users to add to the world');
            }

            // normalize the list of users to an array of user objects
            users = $.map([].concat(users), function (u) {
                var isObject = $.isPlainObject(u);

                if (typeof u !== 'string' && !isObject) {
                    throw new Error('Some of the users in the list are not in the valid format: ' + u);
                }

                return isObject ? u : { userId: u };
            });

            // check if options were passed as the second parameter
            if ($.isPlainObject(worldId) && !options) {
                options = worldId;
                worldId = null;
            }

            options = options || {};

            // we must have options by now
            if (typeof worldId === 'string') {
                options.filter = worldId;
            }

            setIdFilterOrThrowError(options);

            var updateOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter + '/users' }
            );

            return http.post(users, updateOptions);
        },

        /**
        * Updates a user from a given world (only one user at a time)
        *
        * Supported formats:
        * ws.updateUser({ userId: 'b1c19dda-2d2e-4777-ad5d-3929f17e86d3', role: 'leader' });
        *
        * @param user {object} user object with userId and the new role
        * @param options {object} (Optional) Options object to override global options
        *
        */
        updateUser: function (user, options) {
            options = options || {};

            if (!user || !user.userId) {
                throw new Error('You need to pass a userId to remove from the world');
            }

            setIdFilterOrThrowError(options);

            var patchOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter + '/users/' + user.userId }
            );

            return http.patch(_pick(user, 'role'), patchOptions);
        },

        /**
        * Remove a user from a given world (only one user at a time)
        *
        * Supported formats:
        * ws.removeUser('b1c19dda-2d2e-4777-ad5d-3929f17e86d3');
        * ws.removeUser({ userId: 'b1c19dda-2d2e-4777-ad5d-3929f17e86d3' });
        *
        * @param user {object|string} user object with userId field defined or string with userId
        * @param options {object} (Optional) Options object to override global options
        *
        */
        removeUser: function (user, options) {
            options = options || {};

            if (typeof user === 'string') {
                user = { userId: user };
            }

            if (!user.userId) {
                throw new Error('You need to pass a userId to remove from the world');
            }

            setIdFilterOrThrowError(options);

            var getOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter + '/users/' + user.userId }
            );

            return http.delete(null, getOptions);
        },

        /**
        * Get's (or creates) the current run for the given world
        *
        */
        getCurrentRunId: function (options) {
            options = options || {};

            setIdFilterOrThrowError(options);

            var getOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter + '/run' }
            );

            return http.post(null, getOptions);
        },

        /**
        * Get's the current (latest) world for the given user at the given group
        *
        */
        getCurrentWorldForUser: function (userId, groupName) {
            var dtd = $.Deferred();
            var me = this;
            this.getWorldsForUser(userId, { group: groupName })
                .then(function (worlds) {
                    // assume the most recent world as the 'active' world
                    worlds.sort(function (a, b) { return new Date(b.lastModified) - new Date(a.lastModified); });
                    var currentWorld = worlds[0];

                    if (currentWorld) {
                        serviceOptions.filter =  currentWorld.id;
                    }

                    dtd.resolve(currentWorld, me);
                })
                .fail(dtd.reject);

            return dtd.promise();
        },

        /**
        * Delete's the current run from the world
        *
        */
        deleteRun: function (worldId, options) {
            options = options || {};

            if (worldId) {
                options.filter = worldId;
            }

            setIdFilterOrThrowError(options);

            var deleteOptions = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(apiEndpoint) + serviceOptions.filter + '/run' }
            );

            return http.delete(null, deleteOptions);
        },

        newRunForWorld: function (worldId, options) {
            return this.deleteRun(worldId)
                .then(function () {
                    return this.getCurrentRunId({ filter: worldId });
                });
        },

        /**
        * autoAssign users to worlds
        *
        *
        */
        autoAssign: function (options) {
            options = options || {};

            var opt = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(assignmentEndpoint) }
            );

            var params = {
                account: opt.account,
                project: opt.project,
                group: opt.group
            };

            if (opt.maxUsers) {
                params.maxUsers = opt.maxUsers;
            }

            return http.post(params, opt);
        },

        /**
        * Get the project's multiuser configuration
        *
        *
        */
        getProjectSettings: function (options) {
            options = options || {};

            var opt = $.extend(true, {},
                serviceOptions,
                options,
                { url: urlConfig.getAPIPath(projectEndpoint) }
            );

            opt.url += [opt.account, opt.project].join('/');

            return http.get(null, opt);
        }

    };

    $.extend(this, publicAPI);
};
